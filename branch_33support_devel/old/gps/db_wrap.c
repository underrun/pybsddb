/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3u-20001127-1711 (Alpha 5)
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

#define SWIGPYTHON
/***********************************************************************
 * common.swg
 *
 *     This file contains generic SWIG runtime support for pointer
 *     type checking as well as a few commonly used macros to control
 *     external linkage.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 *
 * Copyright (c) 1999-2000, The University of Chicago
 * 
 * This file may be freely redistributed without license or fee provided
 * this copyright message remains intact.
 ************************************************************************/

#include <string.h>

#if defined(_WIN32) || defined(__WIN32__)
#       if defined(_MSC_VER)
#               if defined(STATIC_LINKED)
#                       define SWIGEXPORT(a) a
#               else
#                       define SWIGEXPORT(a) __declspec(dllexport) a
#               endif
#       else
#               if defined(__BORLANDC__)
#                       define SWIGEXPORT(a) a _export
#               else
#                       define SWIGEXPORT(a) a
#       endif
#endif
#else
#       define SWIGEXPORT(a) a
#endif

#ifdef SWIG_GLOBAL
#define SWIGRUNTIME(a) SWIGEXPORT(a)
#else
#define SWIGRUNTIME(a) static a
#endif

#ifdef __cplusplus
extern "C" {
#endif

typedef struct swig_type_info {
  char  *name;                 
  void *(*converter)(void *);
  char  *str;
  struct swig_type_info  *next;
  struct swig_type_info  *prev;
} swig_type_info;

#ifdef SWIG_NOINCLUDE
SWIGEXPORT(swig_type_info *) SWIG_TypeRegister(swig_type_info *);
SWIGEXPORT(swig_type_info *) SWIG_TypeCheck(char *c, swig_type_info *);
SWIGEXPORT(void *) SWIG_TypeCast(swig_type_info *, void *);
#else

static swig_type_info *swig_type_list = 0;

/* Register a type mapping with the type-checking */
SWIGRUNTIME(swig_type_info *)
SWIG_TypeRegister(swig_type_info *ti)
{
  swig_type_info *tc, *head, *ret, *next;
  /* Check to see if this type has already been registered */
  tc = swig_type_list;
  while (tc) {
    if (strcmp(tc->name, ti->name) == 0) {
      /* Already exists in the table.  Just add additional types to the list */
      head = tc;
      next = tc->next;
      goto l1;
    }
    tc = tc->prev;
  }
  head = ti;
  next = 0;

  /* Place in list */
  ti->prev = swig_type_list;
  swig_type_list = ti;

  /* Build linked lists */
 l1:
  ret = head;
  tc = ti + 1;
  /* Patch up the rest of the links */
  while (tc->name) {
    head->next = tc;
    tc->prev = head;
    head = tc;
    tc++;
  }
  head->next = next;
  return ret;
}

/* Check the typename */
SWIGRUNTIME(swig_type_info *) 
SWIG_TypeCheck(char *c, swig_type_info *ty)
{
  swig_type_info *s;
  if (!ty) return 0;        /* Void pointer */
  s = ty->next;             /* First element always just a name */
  while (s) {
    if (strcmp(s->name,c) == 0) {
      if (s == ty->next) return s;
      /* Move s to the top of the linked list */
      s->prev->next = s->next;
      if (s->next) {
	s->next->prev = s->prev;
      }
      /* Insert s as second element in the list */
      s->next = ty->next;
      if (ty->next) ty->next->prev = s;
      ty->next = s;
      return s;
    }
    s = s->next;
  }
  return 0;
}

/* Cast a pointer (needed for C++ inheritance */
SWIGRUNTIME(void *) 
SWIG_TypeCast(swig_type_info *ty, void *ptr) 
{
  if ((!ty) || (!ty->converter)) return ptr;
  return (*ty->converter)(ptr);
}

/* Search for a swig_type_info structure */
SWIGRUNTIME(void *)
SWIG_TypeQuery(const char *name) {
  swig_type_info *ty = swig_type_list;
  while (ty) {
    if (ty->str && (strcmp(name,ty->str) == 0)) return ty;
    if (ty->name && (strcmp(name,ty->name) == 0)) return ty;
    ty = ty->prev;
  }
  return 0;
}

#endif

#ifdef __cplusplus
}
#endif



/***********************************************************************
 * python.swg
 *
 *     This file contains the runtime support for Python modules
 *     and includes code for managing global variables and pointer
 *     type checking.
 *
 * Author : David Beazley (beazley@cs.uchicago.edu)
 ************************************************************************/

#include <stdlib.h>
#include "Python.h"

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_PY_INT     1
#define SWIG_PY_FLOAT   2
#define SWIG_PY_STRING  3
#define SWIG_PY_POINTER 4

/* Constant information structure */
typedef struct swig_const_info {
    int type;
    char *name;
    long lvalue;
    double dvalue;
    void   *pvalue;
    swig_type_info **ptype;
} swig_const_info;

#ifdef SWIG_NOINCLUDE

SWIGEXPORT(PyObject *)        SWIG_newvarlink();
SWIGEXPORT(void)              SWIG_addvarlink(PyObject *, char *, PyObject *(*)(void), int (*)(PyObject *));
SWIGEXPORT(int)               SWIG_ConvertPtr(PyObject *, void **, swig_type_info *, int);
SWIGEXPORT(void)              SWIG_MakePtr(char *c, void *, swig_type_info *);
SWIGEXPORT(PyObject *)        SWIG_NewPointerObj(void *, swig_type_info *);
SWIGEXPORT(void)              SWIG_InstallConstants(PyObject *d, swig_const_info constants[]);

#else

/* -----------------------------------------------------------------------------
 * global variable support code.
 * ----------------------------------------------------------------------------- */

typedef struct swig_globalvar {   
  char       *name;                  /* Name of global variable */
  PyObject *(*get_attr)(void);       /* Return the current value */
  int       (*set_attr)(PyObject *); /* Set the value */
  struct swig_globalvar *next;
} swig_globalvar;

typedef struct swig_varlinkobject {
  PyObject_HEAD
  swig_globalvar *vars;
} swig_varlinkobject;

static PyObject *
swig_varlink_repr(swig_varlinkobject *v) {
  v = v;
  return PyString_FromString("<Global variables>");
}

static int
swig_varlink_print(swig_varlinkobject *v, FILE *fp, int flags) {
  swig_globalvar  *var;
  flags = flags;
  fprintf(fp,"Global variables { ");
  for (var = v->vars; var; var=var->next) {
    fprintf(fp,"%s", var->name);
    if (var->next) fprintf(fp,", ");
  }
  fprintf(fp," }\n");
  return 0;
}

static PyObject *
swig_varlink_getattr(swig_varlinkobject *v, char *n) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->get_attr)();
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return NULL;
}

static int
swig_varlink_setattr(swig_varlinkobject *v, char *n, PyObject *p) {
  swig_globalvar *var = v->vars;
  while (var) {
    if (strcmp(var->name,n) == 0) {
      return (*var->set_attr)(p);
    }
    var = var->next;
  }
  PyErr_SetString(PyExc_NameError,"Unknown C global variable");
  return 1;
}

statichere PyTypeObject varlinktype = {
  PyObject_HEAD_INIT(0)              
  0,
  "swigvarlink",                      /* Type name    */
  sizeof(swig_varlinkobject),         /* Basic size   */
  0,                                  /* Itemsize     */
  0,                                  /* Deallocator  */ 
  (printfunc) swig_varlink_print,     /* Print        */
  (getattrfunc) swig_varlink_getattr, /* get attr     */
  (setattrfunc) swig_varlink_setattr, /* Set attr     */
  0,                                  /* tp_compare   */
  (reprfunc) swig_varlink_repr,       /* tp_repr      */    
  0,                                  /* tp_as_number */
  0,                                  /* tp_as_mapping*/
  0,                                  /* tp_hash      */
};

/* Create a variable linking object for use later */
SWIGRUNTIME(PyObject *)
SWIG_newvarlink(void) {
  swig_varlinkobject *result = 0;
  result = PyMem_NEW(swig_varlinkobject,1);
  varlinktype.ob_type = &PyType_Type;    /* Patch varlinktype into a PyType */
  result->ob_type = &varlinktype;
  result->vars = 0;
  result->ob_refcnt = 0;
  Py_XINCREF((PyObject *) result);
  return ((PyObject*) result);
}

SWIGRUNTIME(void)
SWIG_addvarlink(PyObject *p, char *name,
	   PyObject *(*get_attr)(void), int (*set_attr)(PyObject *p)) {
  swig_varlinkobject *v;
  swig_globalvar *gv;
  v= (swig_varlinkobject *) p;
  gv = (swig_globalvar *) malloc(sizeof(swig_globalvar));
  gv->name = (char *) malloc(strlen(name)+1);
  strcpy(gv->name,name);
  gv->get_attr = get_attr;
  gv->set_attr = set_attr;
  gv->next = v->vars;
  v->vars = gv;
}
/* Convert a pointer value */
SWIGRUNTIME(int)
SWIG_ConvertPtr(PyObject *obj, void **ptr, swig_type_info *ty, int flags) {
  unsigned long p;
  register int d;
  swig_type_info *tc;
  char  *c;
  static PyObject *SWIG_this = 0;
  int    newref = 0;

  if (!obj || (obj == Py_None)) {
    *ptr = 0;
    return 0;
  }
#ifdef SWIG_COBJECT_TYPES
  if (!(PyCObject_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyCObject_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  *ptr = PyCObject_AsVoidPtr(obj);
  c = (char *) PyCObject_GetDesc(obj);
  if (newref) Py_DECREF(obj);
  goto cobject;
#else
  if (!(PyString_Check(obj))) {
    if (!SWIG_this)
      SWIG_this = PyString_InternFromString("this");
    obj = PyObject_GetAttr(obj,SWIG_this);
    newref = 1;
    if (!obj) goto type_error;
    if (!PyString_Check(obj)) {
      Py_DECREF(obj);
      goto type_error;
    }
  } 
  c = PyString_AsString(obj);
  p = 0;
  /* Pointer values must start with leading underscore */
  if (*c != '_') {
    *ptr = (void *) 0;
    if (strcmp(c,"NULL") == 0) {
      if (newref) Py_DECREF(obj);
      return 0;
    } else {
      if (newref) Py_DECREF(obj);
      goto type_error;
    }
  }
  c++;
  /* Extract hex value from pointer */
  while ((d = *c)) {
    if ((d >= '0') && (d <= '9'))
      p = (p << 4) + (d - '0');
    else if ((d >= 'a') && (d <= 'f'))
      p = (p << 4) + (d - ('a'-10));
    else
      break; 
    c++;
  }
  *ptr = (void *) p;
  if (newref) Py_DECREF(obj);
#endif

#ifdef SWIG_COBJECT_TYPES
cobject:
#endif

  if (ty) {
    tc = SWIG_TypeCheck(c,ty);
    if (!tc) goto type_error;
    *ptr = SWIG_TypeCast(tc,(void*)p);
  }
  return 0;

type_error:

  if (flags) {
    if (ty) {
      char *temp = (char *) malloc(64+strlen(ty->name));
      sprintf(temp,"Type error. Expected %s", ty->name);
      PyErr_SetString(PyExc_TypeError, temp);
      free((char *) temp);
    } else {
      PyErr_SetString(PyExc_TypeError,"Expected a pointer");
    }
  }
  return -1;
}

/* Take a pointer and convert it to a string */
SWIGRUNTIME(void) 
SWIG_MakePtr(char *c, void *ptr, swig_type_info *ty) {
  static char hex[17] = "0123456789abcdef";
  unsigned long p, s;
  char result[32], *r; 
  r = result;
  p = (unsigned long) ptr;
  if (p > 0) {
    while (p > 0) {
      s = p & 0xf;
      *(r++) = hex[s];
      p = p >> 4;
    }
    *r = '_';
    while (r >= result)
      *(c++) = *(r--);
    strcpy (c, ty->name);
  } else {
    strcpy (c, "NULL");
  }
}

/* Create a new pointer object */
SWIGRUNTIME(PyObject *)
SWIG_NewPointerObj(void *ptr, swig_type_info *type) {
  char result[512];
  PyObject *robj;
  if (!ptr) {
    Py_INCREF(Py_None);
    return Py_None;
  }
#ifdef SWIG_COBJECT_TYPES
  robj = PyCObject_FromVoidPtrAndDesc((void *) ptr, type->name, NULL);
#else
  SWIG_MakePtr(result,ptr,type);
  robj = PyString_FromString(result);
#endif
  return robj;
}

/* Install Constants */
SWIGRUNTIME(void)
SWIG_InstallConstants(PyObject *d, swig_const_info constants[]) {
  int i;
  PyObject *obj;
  for (i = 0; constants[i].type; i++) {
    switch(constants[i].type) {
    case SWIG_PY_INT:
      obj = PyInt_FromLong(constants[i].lvalue);
      break;
    case SWIG_PY_FLOAT:
      obj = PyFloat_FromDouble(constants[i].dvalue);
      break;
    case SWIG_PY_STRING:
      obj = PyString_FromString((char *) constants[i].pvalue);
      break;
    case SWIG_PY_POINTER:
      obj = SWIG_NewPointerObj(constants[i].pvalue, *(constants[i]).ptype);
      break;
    default:
      obj = 0;
      break;
    }
    if (obj) {
      PyDict_SetItemString(d,constants[i].name,obj);
      Py_DECREF(obj);
    }
  }
}

#endif

#ifdef __cplusplus
}
#endif



/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_MyDB_ENV swig_types[0] 
#define  SWIGTYPE_p___db_txn swig_types[1] 
#define  SWIGTYPE_p_MyDB swig_types[2] 
#define  SWIGTYPE_p_MyDBC swig_types[3] 
static swig_type_info *swig_types[5];

/* -------- TYPES TABLE (END) -------- */


/*-----------------------------------------------
              @(target):= dbc.so
  ------------------------------------------------*/
#define SWIG_init    initdbc

#define SWIG_name    "dbc"

#include <db.h>

static PyObject* l_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyList_Check(target)) {
            o2 = target;
            target = PyList_New(0);
            PyList_Append(target, o2);
	    Py_XDECREF(o2);
        }
        PyList_Append(target,o);
	Py_XDECREF(o);
    }
    return target;
}

static PyObject* t_output_helper(PyObject* target, PyObject* o) {
    PyObject*   o2;
    PyObject*   o3;

    if (!target) {                   
        target = o;
    } else if (target == Py_None) {  
        Py_DECREF(Py_None);
        target = o;
    } else {                         
        if (!PyTuple_Check(target)) {
            o2 = target;
            target = PyTuple_New(1);
            PyTuple_SetItem(target, 0, o2);
        }
        o3 = PyTuple_New(1);            
        PyTuple_SetItem(o3, 0, o);      

        o2 = target;
        target = PySequence_Concat(o2, o3); 
        Py_DECREF(o2);                      
        Py_DECREF(o3);
    }
    return target;
}

struct __db_txn;        // from <db.h>

static PyObject* dbError;             // Make an error variable for exceptions

struct MyDB_ENV {
    DB_ENV* db_env;
    DB_TXN* autoTrans;
    int     flags;             // saved flags from open()
    int     atRefCnt;
    int     closed;
};

struct MyDB {
    DB*             db;
    struct MyDB_ENV* myenv;
    PyObject*       myenvobj;  // PyObject "containing" the above MyDB_ENV
    int             flags;     // saved flags from open()
    long            size;
    int             closed;
};

#define CHECK_DBFLAG(mydb, flag)        ( ((mydb)->flags & (flag)) || ((mydb)->myenv->flags & (flag)) )

struct MyDBC {
    DBC*            dbc;
    struct MyDB*    mydb;
    PyObject*       mydbobj;  // PyObject "containing" the above MyDB
    int             closed;
};

/* make a nice error object to raise for errors. */
static PyObject* makeDbError(int err) {
    struct { int code; char* text; } errors[] = {
        { DB_INCOMPLETE,        "DB_INCOMPLETE: Sync didn't finish" },
        { DB_KEYEMPTY,          "DB_KEYEMPTY: The key/data pair was deleted or was never created" },
        { DB_KEYEXIST,          "DB_KEYEXIST: The key/data pair already exists" },
        { DB_LOCK_DEADLOCK,     "DB_LOCK_DEADLOCK: Locker killed to resolve deadlock" },
        { DB_LOCK_NOTGRANTED,   "DB_LOCK_NOTGRANTED: Lock unavailable, no-wait set" },
        { DB_NOTFOUND,          "DB_NOTFOUND: Key/data pair not found (EOF)" },
        { DB_OLD_VERSION,       "DB_OLD_VERSION: Out-of-date version" },
        { DB_RUNRECOVERY,       "DB_RUNRECOVERY: PANIC!  Run recovery utilities" },
        { -99,                  "UNKNOWN ERROR!!!" },
    };
    int         i;
    char*       errTxt;
    int         numErrors = sizeof(errors) / sizeof(errors[0]);

    if (err < 0) {
        for (i=0; i<numErrors; i++) {
            errTxt = errors[i].text;
            if (err == errors[i].code) break;
        }
    }
    else {
        errTxt = strerror(err);
    }

    return Py_BuildValue("(is)", err, errTxt);
}

// Used to pass errors up to raise exceptions.  The setting and
// testing of this variable must happen while threads are disabled to
// prevent threads from clobbering eachother's return values.
static int MyDb_ErrorValue = 0;

#define passthruError  -2872  // XXX a value not used by BerkeleyDB or errno

#define RETURN_IF_ERR()   { MyDb_ErrorValue = err; if (err) return NULL; }
#define RETURN_PASS()  { MyDb_ErrorValue = passthruError; return NULL; }
#define RETURN_NONE()  { Py_INCREF(Py_None); return Py_None; }

#define MYDB_BEGIN_ALLOW_THREADS Py_BEGIN_ALLOW_THREADS;
#define MYDB_END_ALLOW_THREADS Py_END_ALLOW_THREADS;

#ifdef __cplusplus
extern "C" {
#endif
static PyObject *_wrap_version(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    int *arg0 ;
    int *arg1 ;
    int *arg2 ;
    int temp ;
    int temp0 ;
    int temp1 ;
    char *kwnames[] = {
        NULL 
    };
    char *result ;
    
    {
        arg0 = &temp;
    }
    {
        arg1 = &temp0;
    }
    {
        arg2 = &temp1;
    }
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,":version",kwnames)) return NULL;
    {
        //printf("### Entering: db_version\n");
        result = (char *)db_version(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: db_version\n");
    }resultobj = PyString_FromString(result);
    {
        PyObject *o;
        o = PyInt_FromLong((long) (*arg0));
        resultobj = t_output_helper(resultobj, o);
    }
    {
        PyObject *o;
        o = PyInt_FromLong((long) (*arg1));
        resultobj = t_output_helper(resultobj, o);
    }
    {
        PyObject *o;
        o = PyInt_FromLong((long) (*arg2));
        resultobj = t_output_helper(resultobj, o);
    }
    return resultobj;
}


struct __db_txn * new___db_txn(struct MyDB_ENV *myenv,struct __db_txn *parent,long flags) {
    {
        int err;
        struct __db_txn* txn;
        err = txn_begin(myenv->db_env, parent, &txn, flags);
        RETURN_IF_ERR();
        return txn;
    }
}


static PyObject *_wrap_new_Txn(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    struct __db_txn *arg1 = NULL ;
    long arg2 = 0 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    char *kwnames[] = {
        "myenv","parent","flags", NULL 
    };
    struct __db_txn *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|Ol:new_Txn",kwnames,&argo0,&argo1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: new___db_txn\n");
        result = (struct __db_txn *)new___db_txn(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: new___db_txn\n");
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p___db_txn);
    return resultobj;
}


PyObject * __db_txn_abort(struct __db_txn *self) {
    {
        int err;
        err = txn_abort(self);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Txn_abort(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct __db_txn *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Txn_abort",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: __db_txn_abort\n");
        result = (PyObject *)__db_txn_abort(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: __db_txn_abort\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * __db_txn_prepare(struct __db_txn *self) {
    {
        int err = txn_prepare(self);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Txn_prepare(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct __db_txn *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Txn_prepare",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: __db_txn_prepare\n");
        result = (PyObject *)__db_txn_prepare(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: __db_txn_prepare\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * __db_txn_commit(struct __db_txn *self,long flags) {
    {
        int err;
        err = txn_commit(self, flags);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Txn_commit(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct __db_txn *arg0 ;
    long arg1 = 0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|l:Txn_commit",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: __db_txn_commit\n");
        result = (PyObject *)__db_txn_commit(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: __db_txn_commit\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


struct MyDB_ENV * new_MyDB_ENV() {
    {
        int err;
        struct MyDB_ENV* new_envp;
        new_envp = (struct MyDB_ENV*)PyMem_Malloc(sizeof(struct MyDB_ENV));
        if (!new_envp) {
            PyErr_SetString(PyExc_MemoryError, "PyMem_Malloc failed");
            RETURN_PASS();
        }
        err = db_env_create(&new_envp->db_env, 0);
        RETURN_IF_ERR();
        new_envp->closed = 1;
        new_envp->autoTrans = NULL;
        new_envp->atRefCnt = 0;
        new_envp->flags = 0;
        return new_envp;
    }
}


static PyObject *_wrap_new_DbEnv(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    char *kwnames[] = {
        NULL 
    };
    struct MyDB_ENV *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,":new_DbEnv",kwnames)) return NULL;
    {
        //printf("### Entering: new_MyDB_ENV\n");
        result = (struct MyDB_ENV *)new_MyDB_ENV();
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: new_MyDB_ENV\n");
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MyDB_ENV);
    return resultobj;
}


void  delete_MyDB_ENV(struct MyDB_ENV *self) {
    {
        if (!self->closed) {
            self->db_env->close(self->db_env, 0);
            // return value ignored in destructor, possibly bad...?
        }
        PyMem_Free(self);
    }
}


static PyObject *_wrap_delete_DbEnv(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:delete_DbEnv",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: delete_MyDB_ENV\n");
        delete_MyDB_ENV(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: delete_MyDB_ENV\n");
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


PyObject * MyDB_ENV_open(struct MyDB_ENV *self,char *db_home,long flags) {
    {
        int err = self->db_env->open(self->db_env, db_home, flags, 0);
        RETURN_IF_ERR();
        self->closed = 0;
        self->flags = flags;
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_open(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    char *arg1 ;
    long arg2 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","db_home","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Osl:DbEnv_open",kwnames,&argo0,&arg1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_open\n");
        result = (PyObject *)MyDB_ENV_open(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_open\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_close(struct MyDB_ENV *self) {
    {
        int err;
        if (!self->closed) {
/* Don't close more than once */
                err = self->db_env->close(self->db_env, 0);
                RETURN_IF_ERR();
                self->closed = 1;
            }
            RETURN_NONE();
        }
}


static PyObject *_wrap_DbEnv_close(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:DbEnv_close",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_close\n");
        result = (PyObject *)MyDB_ENV_close(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_close\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_set_data_dir(struct MyDB_ENV *self,char *dir) {
    {
        int err = self->db_env->set_data_dir(self->db_env, dir);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_set_data_dir(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    char *arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","dir", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Os:DbEnv_set_data_dir",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_set_data_dir\n");
        result = (PyObject *)MyDB_ENV_set_data_dir(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_set_data_dir\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_set_lg_dir(struct MyDB_ENV *self,char *dir) {
    {
        int err = self->db_env->set_lg_dir(self->db_env, dir);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_set_lg_dir(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    char *arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","dir", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Os:DbEnv_set_lg_dir",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_set_lg_dir\n");
        result = (PyObject *)MyDB_ENV_set_lg_dir(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_set_lg_dir\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_set_tmp_dir(struct MyDB_ENV *self,char *dir) {
    {
        int err = self->db_env->set_tmp_dir(self->db_env, dir);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_set_tmp_dir(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    char *arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","dir", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Os:DbEnv_set_tmp_dir",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_set_tmp_dir\n");
        result = (PyObject *)MyDB_ENV_set_tmp_dir(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_set_tmp_dir\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_set_cachesize(struct MyDB_ENV *self,int gbytes,int bytes,int ncache) {
    {
        int err = self->db_env->set_cachesize(self->db_env, gbytes, bytes, ncache);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_set_cachesize(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    int arg1 = 0 ;
    int arg2 = 0 ;
    int arg3 = 0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","gbytes","bytes","ncache", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|iii:DbEnv_set_cachesize",kwnames,&argo0,&arg1,&arg2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_set_cachesize\n");
        result = (PyObject *)MyDB_ENV_set_cachesize(arg0,arg1,arg2,arg3);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_set_cachesize\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_set_lg_bsize(struct MyDB_ENV *self,int lg_bsize) {
    {
        int err = self->db_env->set_lg_bsize(self->db_env, lg_bsize);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_set_lg_bsize(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","lg_bsize", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:DbEnv_set_lg_bsize",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_set_lg_bsize\n");
        result = (PyObject *)MyDB_ENV_set_lg_bsize(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_set_lg_bsize\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_set_lg_max(struct MyDB_ENV *self,int lg_max) {
    {
        int err = self->db_env->set_lg_max(self->db_env, lg_max);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_set_lg_max(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","lg_max", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:DbEnv_set_lg_max",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_set_lg_max\n");
        result = (PyObject *)MyDB_ENV_set_lg_max(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_set_lg_max\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_set_lk_detect(struct MyDB_ENV *self,int lk_detect) {
    {
        int err = self->db_env->set_lk_detect(self->db_env, lk_detect);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_set_lk_detect(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","lk_detect", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:DbEnv_set_lk_detect",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_set_lk_detect\n");
        result = (PyObject *)MyDB_ENV_set_lk_detect(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_set_lk_detect\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_set_mp_mmapsize(struct MyDB_ENV *self,int mp_mmapsize) {
    {
        int err = self->db_env->set_mp_mmapsize(self->db_env, mp_mmapsize);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_set_mp_mmapsize(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","mp_mmapsize", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:DbEnv_set_mp_mmapsize",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_set_mp_mmapsize\n");
        result = (PyObject *)MyDB_ENV_set_mp_mmapsize(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_set_mp_mmapsize\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_beginAutoTrans(struct MyDB_ENV *self,long flags) {
    {
        int err;
        if (self->atRefCnt == 0) {
            err = txn_begin(self->db_env, NULL, &self->autoTrans, flags);
            RETURN_IF_ERR();
        }
        self->atRefCnt += 1;
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_beginAutoTrans(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    long arg1 = 0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|l:DbEnv_beginAutoTrans",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_beginAutoTrans\n");
        result = (PyObject *)MyDB_ENV_beginAutoTrans(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_beginAutoTrans\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_abortAutoTrans(struct MyDB_ENV *self) {
    {
        int err;
        if (self->atRefCnt) {
            err = txn_abort(self->autoTrans);
            self->autoTrans = NULL;
            self->atRefCnt = 0;
            RETURN_IF_ERR();
        }
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_abortAutoTrans(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:DbEnv_abortAutoTrans",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_abortAutoTrans\n");
        result = (PyObject *)MyDB_ENV_abortAutoTrans(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_abortAutoTrans\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_prepareAutoTrans(struct MyDB_ENV *self) {
    {
        int err;
        if (self->atRefCnt) {
            err = txn_prepare(self->autoTrans);
            RETURN_IF_ERR();
        }
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_prepareAutoTrans(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:DbEnv_prepareAutoTrans",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_prepareAutoTrans\n");
        result = (PyObject *)MyDB_ENV_prepareAutoTrans(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_prepareAutoTrans\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_ENV_commitAutoTrans(struct MyDB_ENV *self,long flags) {
    {
        int err;
        self->atRefCnt -= 1;
        if (self->atRefCnt == 0) {
            err = txn_commit(self->autoTrans, flags);
            RETURN_IF_ERR();
        }
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_commitAutoTrans(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    long arg1 = 0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|l:DbEnv_commitAutoTrans",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_commitAutoTrans\n");
        result = (PyObject *)MyDB_ENV_commitAutoTrans(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_commitAutoTrans\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


struct __db_txn * MyDB_ENV_txn_begin(struct MyDB_ENV *self,struct __db_txn *parent,long flags) {
    {
        return new___db_txn(self, parent, flags);
    }
}


static PyObject *_wrap_DbEnv_txn_begin(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    struct __db_txn *arg1 = NULL ;
    long arg2 = 0 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    char *kwnames[] = {
        "self","parent","flags", NULL 
    };
    struct __db_txn *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|Ol:DbEnv_txn_begin",kwnames,&argo0,&argo1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_txn_begin\n");
        result = (struct __db_txn *)MyDB_ENV_txn_begin(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_txn_begin\n");
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p___db_txn);
    return resultobj;
}


PyObject * MyDB_ENV_txn_checkpoint(struct MyDB_ENV *self,int min,long flags) {
    {
        int err = txn_checkpoint(self->db_env, 0, min, flags);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_DbEnv_txn_checkpoint(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB_ENV *arg0 ;
    int arg1 = 0 ;
    long arg2 = 0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","min","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|il:DbEnv_txn_checkpoint",kwnames,&argo0,&arg1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB_ENV,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_ENV_txn_checkpoint\n");
        result = (PyObject *)MyDB_ENV_txn_checkpoint(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_ENV_txn_checkpoint\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


void  delete_MyDBC(struct MyDBC *self) {
    {
        if (!self->closed) {
            MYDB_BEGIN_ALLOW_THREADS;
            self->dbc->c_close(self->dbc);
            MYDB_END_ALLOW_THREADS;
        }
        // TODO Py_DECREF on the Db object that created us (also INCREF when created)
        PyMem_Free(self);
    }
}


static PyObject *_wrap_delete_Dbc(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:delete_Dbc",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: delete_MyDBC\n");
        delete_MyDBC(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: delete_MyDBC\n");
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


PyObject * MyDBC_close(struct MyDBC *self) {
    {
        int err;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->dbc->c_close(self->dbc);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        self->closed = 1;
        RETURN_NONE();
    }
}


static PyObject *_wrap_Dbc_close(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Dbc_close",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_close\n");
        result = (PyObject *)MyDBC_close(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_close\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_delete(struct MyDBC *self,long flags) {
    {
        int err;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->dbc->c_del(self->dbc, flags);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        self->mydb->size = -1;
        RETURN_NONE();
    }
}


static PyObject *_wrap_Dbc_delete(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    long arg1 = 0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|l:Dbc_delete",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_delete\n");
        result = (PyObject *)MyDBC_delete(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_delete\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_get(struct MyDBC *self,long flags) {
    {
        int err;
        DBT key;
        DBT data;
        PyObject *retval = NULL;
        memset(&key, 0, sizeof(key));
        memset(&data, 0, sizeof(data));
        if (CHECK_DBFLAG(self->mydb, DB_THREAD)) {
            // Tell BerkeleyDB to malloc the return value (thread safe)
            data.flags = DB_DBT_MALLOC;
            key.flags = DB_DBT_MALLOC;
        }
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->dbc->c_get(self->dbc, &key, &data, flags);
        MYDB_END_ALLOW_THREADS;
        
        // emulate Python dict.get() behavior, return None if the key was not found
        if (err == DB_NOTFOUND) {
            Py_INCREF(Py_None);
            retval = Py_None;
        }else {
            RETURN_IF_ERR();
        }
        if (retval == NULL) {
// if we're not returning Py_None
                retval = Py_BuildValue("s#s#", key.data, key.size,
                                             data.data, data.size);
            }
            if (CHECK_DBFLAG(self->mydb, DB_THREAD)) {
                if (key.data != NULL) free(key.data);
                if (data.data != NULL) free(data.data);
            }
            return retval;
        }
}


static PyObject *_wrap_Dbc_get(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    long arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Ol:Dbc_get",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_get\n");
        result = (PyObject *)MyDBC_get(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_get\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_first(struct MyDBC *self) {
    {
        return MyDBC_get(self, DB_FIRST); 
    }
}


static PyObject *_wrap_Dbc_first(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Dbc_first",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_first\n");
        result = (PyObject *)MyDBC_first(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_first\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_last(struct MyDBC *self) {
    {
        return MyDBC_get(self, DB_LAST); 
    }
}


static PyObject *_wrap_Dbc_last(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Dbc_last",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_last\n");
        result = (PyObject *)MyDBC_last(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_last\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_next(struct MyDBC *self) {
    {
        return MyDBC_get(self, DB_NEXT); 
    }
}


static PyObject *_wrap_Dbc_next(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Dbc_next",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_next\n");
        result = (PyObject *)MyDBC_next(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_next\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_prev(struct MyDBC *self) {
    {
        return MyDBC_get(self, DB_PREV); 
    }
}


static PyObject *_wrap_Dbc_prev(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Dbc_prev",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_prev\n");
        result = (PyObject *)MyDBC_prev(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_prev\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_current(struct MyDBC *self) {
    {
        return MyDBC_get(self, DB_CURRENT);   
    }
}


static PyObject *_wrap_Dbc_current(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Dbc_current",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_current\n");
        result = (PyObject *)MyDBC_current(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_current\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_set(struct MyDBC *self,DBT *keyp) {
    {
        int err;
        DBT data;
        PyObject *retval;
        memset(&data, 0, sizeof(data));
        if (CHECK_DBFLAG(self->mydb, DB_THREAD)) {
            // Tell BerkeleyDB to malloc the return value (thread safe)
            data.flags = DB_DBT_MALLOC;
        }
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->dbc->c_get(self->dbc, keyp, &data, DB_SET);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        retval = Py_BuildValue("s#s#", keyp->data, keyp->size,
        data.data, data.size);
        if (CHECK_DBFLAG(self->mydb, DB_THREAD)) {
            if (data.data != NULL) free(data.data);
        }
        return retval;
    }
}


static PyObject *_wrap_Dbc_set(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    DBT *arg1 ;
    PyObject * argo0 =0 ;
    DBT dbt ;
    PyObject * obj1  = 0 ;
    char *kwnames[] = {
        "self","keyp", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OO:Dbc_set",kwnames,&argo0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        memset(&dbt, 0, sizeof(dbt));
        if (obj1 == Py_None) {
            dbt.data = NULL;
            dbt.size = 0;
        }else if (!PyArg_Parse(obj1, "s#", &dbt.data, &dbt.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg1 = &dbt;
    }
    {
        //printf("### Entering: MyDBC_set\n");
        result = (PyObject *)MyDBC_set(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_set\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_setRange(struct MyDBC *self,DBT *keyp) {
    {
        int err;
        DBT data;
        PyObject *retval;
        memset(&data, 0, sizeof(data));
        if (CHECK_DBFLAG(self->mydb, DB_THREAD)) {
            // Tell BerkeleyDB to malloc the return value (thread safe)
            data.flags = DB_DBT_MALLOC;
            keyp->flags = DB_DBT_MALLOC;
        }
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->dbc->c_get(self->dbc, keyp, &data, DB_SET_RANGE);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        retval = Py_BuildValue("s#s#", keyp->data, keyp->size,
        data.data, data.size);
        if (CHECK_DBFLAG(self->mydb, DB_THREAD)) {
            if (keyp->data != NULL) free(keyp->data);
            if (data.data != NULL) free(data.data);
        }
        return retval;
    }
}


static PyObject *_wrap_Dbc_setRange(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    DBT *arg1 ;
    PyObject * argo0 =0 ;
    DBT dbt ;
    PyObject * obj1  = 0 ;
    char *kwnames[] = {
        "self","keyp", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OO:Dbc_setRange",kwnames,&argo0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        memset(&dbt, 0, sizeof(dbt));
        if (obj1 == Py_None) {
            dbt.data = NULL;
            dbt.size = 0;
        }else if (!PyArg_Parse(obj1, "s#", &dbt.data, &dbt.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg1 = &dbt;
    }
    {
        //printf("### Entering: MyDBC_setRange\n");
        result = (PyObject *)MyDBC_setRange(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_setRange\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_setRecno(struct MyDBC *self,db_recno_t recno) {
    {
        int err;
        DBT key;
        DBT data;
        PyObject *retval;
        key.data = &recno;
        key.size = sizeof(db_recno_t);
        key.ulen = key.size;
        key.flags = DB_DBT_USERMEM;
        memset(&data, 0, sizeof(data));
        if (CHECK_DBFLAG(self->mydb, DB_THREAD)) {
            // Tell BerkeleyDB to malloc the return value (thread safe)
            data.flags = DB_DBT_MALLOC;
        }
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->dbc->c_get(self->dbc, &key, &data, DB_SET_RECNO);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        retval = Py_BuildValue("s#s#", key.data, key.size,
        data.data, data.size);
        if (CHECK_DBFLAG(self->mydb, DB_THREAD) && (data.data != NULL)) {
            free(data.data);
        }
        return retval;
    }
}


static PyObject *_wrap_Dbc_setRecno(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    db_recno_t arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","recno", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:Dbc_setRecno",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_setRecno\n");
        result = (PyObject *)MyDBC_setRecno(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_setRecno\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_getRecno(struct MyDBC *self) {
    {
        int err;
        db_recno_t recno;
        DBT key;
        DBT data;
        memset(&key, 0, sizeof(key));
        memset(&data, 0, sizeof(data));
        if (CHECK_DBFLAG(self->mydb, DB_THREAD)) {
            // Tell BerkeleyDB to malloc the return value (thread safe)
            data.flags = DB_DBT_MALLOC;
            key.flags = DB_DBT_MALLOC;
        }
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->dbc->c_get(self->dbc, &key, &data, DB_GET_RECNO);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        memcpy(&recno, data.data, sizeof(db_recno_t));
        if (CHECK_DBFLAG(self->mydb, DB_THREAD)) {
            if (key.data != NULL) free(key.data);
            if (data.data != NULL) free(data.data);
        }
        return PyInt_FromLong(recno);
    }
}


static PyObject *_wrap_Dbc_getRecno(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Dbc_getRecno",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_getRecno\n");
        result = (PyObject *)MyDBC_getRecno(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_getRecno\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_put(struct MyDBC *self,DBT *keyp,DBT *datap,long flags) {
    {
        int err;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->dbc->c_put(self->dbc, keyp, datap, flags);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        self->mydb->size = -1;
        RETURN_NONE();
    }
}


static PyObject *_wrap_Dbc_put(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    DBT *arg1 ;
    DBT *arg2 ;
    long arg3 ;
    PyObject * argo0 =0 ;
    DBT dbt ;
    PyObject * obj1  = 0 ;
    DBT dbt0 ;
    PyObject * obj2  = 0 ;
    char *kwnames[] = {
        "self","keyp","datap","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OOOl:Dbc_put",kwnames,&argo0,&obj1,&obj2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        memset(&dbt, 0, sizeof(dbt));
        if (obj1 == Py_None) {
            dbt.data = NULL;
            dbt.size = 0;
        }else if (!PyArg_Parse(obj1, "s#", &dbt.data, &dbt.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg1 = &dbt;
    }
    {
        memset(&dbt0, 0, sizeof(dbt0));
        if (obj2 == Py_None) {
            dbt0.data = NULL;
            dbt0.size = 0;
        }else if (!PyArg_Parse(obj2, "s#", &dbt0.data, &dbt0.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg2 = &dbt0;
    }
    {
        //printf("### Entering: MyDBC_put\n");
        result = (PyObject *)MyDBC_put(arg0,arg1,arg2,arg3);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_put\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDBC_count(struct MyDBC *self) {
    {
        int err;
        db_recno_t mycount;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->dbc->c_count(self->dbc, &mycount, 0);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        return PyInt_FromLong(mycount);
    }
}


static PyObject *_wrap_Dbc_count(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDBC *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Dbc_count",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDBC,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDBC_count\n");
        result = (PyObject *)MyDBC_count(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDBC_count\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


struct MyDB * new_MyDB(PyObject *pyDbEnv) {
    {
        int err;
        struct MyDB* self = (struct MyDB*)PyMem_Malloc(sizeof(struct MyDB));
        
        if (!self) {
            PyErr_SetString(PyExc_MemoryError, "PyMem_Malloc failed");
            RETURN_PASS();
        }
        memset(self, 0, sizeof(struct MyDB));
        self->size = -1;
        self->closed = 1;
        self->flags = 0;
        
        // be sure we got a MyDB_ENV object
        
        // for SWIG v1.3a5 do this:
        if (SWIG_ConvertPtr(pyDbEnv, (void **) &self->myenv,
        SWIGTYPE_p_MyDB_ENV, 0))   // the 0 flag means we set the error ourself
        
        
        
        
        
        {
            PyMem_Free(self);
            PyErr_SetString(PyExc_TypeError,
            "DbEnv object expected in argument 1");
            RETURN_PASS();
        }
        
        // keep a reference to our python DbEnv object
        Py_INCREF(pyDbEnv);
        self->myenvobj = pyDbEnv;
        
        err = db_create(&self->db, self->myenv->db_env, 0);
        RETURN_IF_ERR();
        
        return self;
    }
}


static PyObject *_wrap_new_Db(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    PyObject *arg0 ;
    PyObject * obj0  = 0 ;
    char *kwnames[] = {
        "pyDbEnv", NULL 
    };
    struct MyDB *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:new_Db",kwnames,&obj0)) return NULL;
    {
        arg0 = obj0;
    }
    {
        //printf("### Entering: new_MyDB\n");
        result = (struct MyDB *)new_MyDB(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: new_MyDB\n");
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MyDB);
    return resultobj;
}


void  delete_MyDB(struct MyDB *self) {
    {
        if (!self->closed) {
            MYDB_BEGIN_ALLOW_THREADS;
            self->db->close(self->db, 0);
            MYDB_END_ALLOW_THREADS;
        }
        if (self->myenvobj) {
            Py_DECREF(self->myenvobj);
            self->myenvobj = NULL;
            self->myenv = NULL;
        }
        PyMem_Free(self);
    }
}


static PyObject *_wrap_delete_Db(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:delete_Db",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: delete_MyDB\n");
        delete_MyDB(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: delete_MyDB\n");
    }Py_INCREF(Py_None);
    resultobj = Py_None;
    return resultobj;
}


PyObject * MyDB_set_cachesize(struct MyDB *self,int gbytes,int bytes,int ncache) {
    {
        int err = self->db->set_cachesize(self->db, gbytes, bytes, ncache);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_cachesize(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    int arg1 = 0 ;
    int arg2 = 0 ;
    int arg3 = 0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","gbytes","bytes","ncache", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|iii:Db_set_cachesize",kwnames,&argo0,&arg1,&arg2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_cachesize\n");
        result = (PyObject *)MyDB_set_cachesize(arg0,arg1,arg2,arg3);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_cachesize\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_lorder(struct MyDB *self,int lorder) {
    {
        int err = self->db->set_lorder(self->db, lorder);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_lorder(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","lorder", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:Db_set_lorder",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_lorder\n");
        result = (PyObject *)MyDB_set_lorder(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_lorder\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_pagesize(struct MyDB *self,int pagesize) {
    {
        int err = self->db->set_pagesize(self->db, pagesize);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_pagesize(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","pagesize", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:Db_set_pagesize",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_pagesize\n");
        result = (PyObject *)MyDB_set_pagesize(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_pagesize\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_bt_minkey(struct MyDB *self,int minkey) {
    {
        int err = self->db->set_bt_minkey(self->db, minkey);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_bt_minkey(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","minkey", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:Db_set_bt_minkey",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_bt_minkey\n");
        result = (PyObject *)MyDB_set_bt_minkey(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_bt_minkey\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_h_ffactor(struct MyDB *self,int ffactor) {
    {
        int err = self->db->set_h_ffactor(self->db, ffactor);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_h_ffactor(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","ffactor", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:Db_set_h_ffactor",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_h_ffactor\n");
        result = (PyObject *)MyDB_set_h_ffactor(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_h_ffactor\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_h_nelem(struct MyDB *self,int nelem) {
    {
        int err = self->db->set_h_nelem(self->db, nelem);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_h_nelem(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","nelem", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:Db_set_h_nelem",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_h_nelem\n");
        result = (PyObject *)MyDB_set_h_nelem(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_h_nelem\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_re_delim(struct MyDB *self,int delim) {
    {
        int err = self->db->set_re_delim(self->db, delim);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_re_delim(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","delim", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:Db_set_re_delim",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_re_delim\n");
        result = (PyObject *)MyDB_set_re_delim(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_re_delim\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_re_len(struct MyDB *self,int len) {
    {
        int err = self->db->set_re_len(self->db, len);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_re_len(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    int arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","len", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi:Db_set_re_len",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_re_len\n");
        result = (PyObject *)MyDB_set_re_len(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_re_len\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_re_pad(struct MyDB *self,char *pad) {
    {
        int err = self->db->set_re_pad(self->db, *pad);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_re_pad(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    char *arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","pad", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Os:Db_set_re_pad",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_re_pad\n");
        result = (PyObject *)MyDB_set_re_pad(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_re_pad\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_re_source(struct MyDB *self,char *re_source) {
    {
        int err = self->db->set_re_source(self->db, re_source);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_re_source(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    char *arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","re_source", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Os:Db_set_re_source",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_re_source\n");
        result = (PyObject *)MyDB_set_re_source(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_re_source\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_set_flags(struct MyDB *self,long flags) {
    {
        int err = self->db->set_flags(self->db, flags);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_set_flags(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    long arg1 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Ol:Db_set_flags",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_set_flags\n");
        result = (PyObject *)MyDB_set_flags(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_set_flags\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_open(struct MyDB *self,char *filename,int type,long flags,int mode) {
    {
        int err;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->open(self->db, filename, NULL,
        type, flags, mode);
        MYDB_END_ALLOW_THREADS;
        if (err) self->db->close(self->db, 0);
        RETURN_IF_ERR();
        self->closed = 0;
        self->flags = flags;
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_open(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    char *arg1 ;
    int arg2 = DB_UNKNOWN ;
    long arg3 = 0 ;
    int arg4 = 0660 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","filename","type","flags","mode", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Os|ili:Db_open",kwnames,&argo0,&arg1,&arg2,&arg3,&arg4)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_open\n");
        result = (PyObject *)MyDB_open(arg0,arg1,arg2,arg3,arg4);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_open\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_upgrade(struct MyDB *self,char *filename,long flags) {
    {
        int err = self->db->upgrade(self->db, filename, flags);
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_upgrade(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    char *arg1 ;
    long arg2 = 0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","filename","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Os|l:Db_upgrade",kwnames,&argo0,&arg1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_upgrade\n");
        result = (PyObject *)MyDB_upgrade(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_upgrade\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


int  MyDB_type(struct MyDB *self) {
    {
        int t;
        MYDB_BEGIN_ALLOW_THREADS;
        t = self->db->get_type(self->db);
        MYDB_END_ALLOW_THREADS;
        return t;
    }
}


static PyObject *_wrap_Db_type(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    int result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Db_type",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_type\n");
        result = (int )MyDB_type(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_type\n");
    }resultobj = PyInt_FromLong((long)result);
    return resultobj;
}


PyObject * MyDB_close(struct MyDB *self,long flags) {
    {
        int err = 0;
        if (!self->closed) {
            MYDB_BEGIN_ALLOW_THREADS;
            err = self->db->close(self->db, flags);
            MYDB_END_ALLOW_THREADS;
        }
        RETURN_IF_ERR();
        self->closed = 1;
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_close(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    long arg1 = 0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|l:Db_close",kwnames,&argo0,&arg1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_close\n");
        result = (PyObject *)MyDB_close(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_close\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


struct MyDBC * MyDB_cursor(struct MyDB *self,struct __db_txn *txn,long flags) {
    {
        int err;
        DBC* dbc;
        struct MyDBC* retval;
        if (!txn) txn = self->myenv->autoTrans;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->cursor(self->db, txn, &dbc, flags);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
// TODO Py_INCREF on the Db object (also DECREF in the cursor's destructor)
            retval = (struct MyDBC*)PyMem_Malloc(sizeof(struct MyDBC));
            retval->dbc = dbc;
            retval->mydb = self;
            retval->closed = 0;
            return retval;              // Let SWIG turn it into a python Dbc
        }
}


static PyObject *_wrap_Db_cursor(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    struct __db_txn *arg1 = NULL ;
    long arg2 = 0 ;
    PyObject * argo0 =0 ;
    PyObject * argo1 =0 ;
    char *kwnames[] = {
        "self","txn","flags", NULL 
    };
    struct MyDBC *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O|Ol:Db_cursor",kwnames,&argo0,&argo1,&arg2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo1,(void **) &arg1,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_cursor\n");
        result = (struct MyDBC *)MyDB_cursor(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_cursor\n");
    }resultobj = SWIG_NewPointerObj((void *) result, SWIGTYPE_p_MyDBC);
    return resultobj;
}


PyObject * MyDB_delete(struct MyDB *self,DBT *keyp,struct __db_txn *txn) {
    {
        int err;
        if (!txn) txn = self->myenv->autoTrans;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->del(self->db, txn, keyp, 0);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        self->size = -1;
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_delete(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    DBT *arg1 ;
    struct __db_txn *arg2 = NULL ;
    PyObject * argo0 =0 ;
    DBT dbt ;
    PyObject * obj1  = 0 ;
    PyObject * argo2 =0 ;
    char *kwnames[] = {
        "self","keyp","txn", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OO|O:Db_delete",kwnames,&argo0,&obj1,&argo2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        memset(&dbt, 0, sizeof(dbt));
        if (obj1 == Py_None) {
            dbt.data = NULL;
            dbt.size = 0;
        }else if (!PyArg_Parse(obj1, "s#", &dbt.data, &dbt.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg1 = &dbt;
    }
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_delete\n");
        result = (PyObject *)MyDB_delete(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_delete\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_get(struct MyDB *self,DBT *keyp,struct __db_txn *txn,long flags) {
    {
        int err;
        DBT data;
        PyObject *retval = NULL;
        // XXX RECNO databases could use another get interface
        // that accepts an integer instead of a string.  (for now,
        // RECNO users need to put the 32-bit integer into a
        // string before calling get)
        memset(&data, 0, sizeof(DBT));
        if (!txn) txn = self->myenv->autoTrans;
        if (CHECK_DBFLAG(self, DB_THREAD)) {
            // Tell BerkeleyDB to malloc the return value (thread safe)
            data.flags = DB_DBT_MALLOC;
        }
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->get(self->db, txn, keyp, &data, flags);
        MYDB_END_ALLOW_THREADS;
        
        // emulate Python dict.get() behavior, return None if the key was not found
        if (err == DB_NOTFOUND) {
            Py_INCREF(Py_None);
            retval = Py_None;
        }else {
            RETURN_IF_ERR();
        }
        if (retval == NULL) {
// if we're not returning Py_None
                retval = PyString_FromStringAndSize((char*)data.data, data.size);
            }
            if ((CHECK_DBFLAG(self, DB_THREAD)) && (data.data != NULL)) {
                free(data.data);
            }
            return retval;
        }
}


static PyObject *_wrap_Db_get(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    DBT *arg1 ;
    struct __db_txn *arg2 = NULL ;
    long arg3 = 0 ;
    PyObject * argo0 =0 ;
    DBT dbt ;
    PyObject * obj1  = 0 ;
    PyObject * argo2 =0 ;
    char *kwnames[] = {
        "self","keyp","txn","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OO|Ol:Db_get",kwnames,&argo0,&obj1,&argo2,&arg3)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        memset(&dbt, 0, sizeof(dbt));
        if (obj1 == Py_None) {
            dbt.data = NULL;
            dbt.size = 0;
        }else if (!PyArg_Parse(obj1, "s#", &dbt.data, &dbt.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg1 = &dbt;
    }
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_get\n");
        result = (PyObject *)MyDB_get(arg0,arg1,arg2,arg3);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_get\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_getRec(struct MyDB *self,db_recno_t recno,struct __db_txn *txn) {
    {
        int err;
        DBT key;
        DBT data;
        PyObject *retval;
        key.data = &recno;
        key.size = sizeof(db_recno_t);
        key.ulen = key.size;
        key.flags = DB_DBT_USERMEM;
        memset(&data, 0, sizeof(data));
        if (CHECK_DBFLAG(self, DB_THREAD)) {
            // Tell BerkeleyDB to malloc the return value (thread safe)
            data.flags = DB_DBT_MALLOC;
        }
        if (!txn) txn = self->myenv->autoTrans;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->get(self->db, txn, &key, &data, DB_SET_RECNO);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        retval = Py_BuildValue("s#s#", key.data, key.size,
        data.data, data.size);
        if ((CHECK_DBFLAG(self, DB_THREAD)) && (data.data != NULL)) {
            free(data.data);
        }
        return retval;
    }
}


static PyObject *_wrap_Db_getRec(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    db_recno_t arg1 ;
    struct __db_txn *arg2 = NULL ;
    PyObject * argo0 =0 ;
    PyObject * argo2 =0 ;
    char *kwnames[] = {
        "self","recno","txn", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"Oi|O:Db_getRec",kwnames,&argo0,&arg1,&argo2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    if ((SWIG_ConvertPtr(argo2,(void **) &arg2,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_getRec\n");
        result = (PyObject *)MyDB_getRec(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_getRec\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_fd(struct MyDB *self) {
    {
        int err;
        int the_fd;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->fd(self->db, &the_fd);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        return PyInt_FromLong(the_fd);
    }
}


static PyObject *_wrap_Db_fd(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Db_fd",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_fd\n");
        result = (PyObject *)MyDB_fd(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_fd\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_put(struct MyDB *self,DBT *keyp,DBT *datap,struct __db_txn *txn,long flags) {
    {
        int err;
        if (!txn) txn = self->myenv->autoTrans;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->put(self->db, txn, keyp, datap, flags);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        self->size = -1;
        // XXX if RECNO type, return as integer
        return Py_BuildValue("s#", keyp->data, keyp->size);
    }
}


static PyObject *_wrap_Db_put(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    DBT *arg1 ;
    DBT *arg2 ;
    struct __db_txn *arg3 = NULL ;
    long arg4 = 0 ;
    PyObject * argo0 =0 ;
    DBT dbt ;
    PyObject * obj1  = 0 ;
    DBT dbt0 ;
    PyObject * obj2  = 0 ;
    PyObject * argo3 =0 ;
    char *kwnames[] = {
        "self","keyp","datap","txn","flags", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OOO|Ol:Db_put",kwnames,&argo0,&obj1,&obj2,&argo3,&arg4)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        memset(&dbt, 0, sizeof(dbt));
        if (obj1 == Py_None) {
            dbt.data = NULL;
            dbt.size = 0;
        }else if (!PyArg_Parse(obj1, "s#", &dbt.data, &dbt.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg1 = &dbt;
    }
    {
        memset(&dbt0, 0, sizeof(dbt0));
        if (obj2 == Py_None) {
            dbt0.data = NULL;
            dbt0.size = 0;
        }else if (!PyArg_Parse(obj2, "s#", &dbt0.data, &dbt0.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg2 = &dbt0;
    }
    if ((SWIG_ConvertPtr(argo3,(void **) &arg3,SWIGTYPE_p___db_txn,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_put\n");
        result = (PyObject *)MyDB_put(arg0,arg1,arg2,arg3,arg4);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_put\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_sync(struct MyDB *self) {
    {
        int err;
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->sync(self->db, 0);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        RETURN_NONE();
    }
}


static PyObject *_wrap_Db_sync(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Db_sync",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_sync\n");
        result = (PyObject *)MyDB_sync(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_sync\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB___len__(struct MyDB *self) {
    {
        int err;
        DBT key;
        DBT data;
        DBC *cursor = NULL;
        long size = 0;
        
        if (self->size < 0) {
            // recompute
            memset(&key, 0, sizeof(DBT));
            memset(&data, 0, sizeof(DBT));
            MYDB_BEGIN_ALLOW_THREADS;
            err = self->db->cursor(self->db, self->myenv->autoTrans, &cursor, 0);
            MYDB_END_ALLOW_THREADS;
            RETURN_IF_ERR();
            while (1) {
                if (CHECK_DBFLAG(self, DB_THREAD)) {
                    // XXX tons of mallocs are highly inefficient
                    key.flags = DB_DBT_REALLOC;
                    data.flags = DB_DBT_REALLOC;
                }
                MYDB_BEGIN_ALLOW_THREADS;
                err = cursor->c_get(cursor, &key, &data, DB_NEXT);
                MYDB_END_ALLOW_THREADS;
                if (err != 0)
                break;
                
                size += 1;
            }
            if (CHECK_DBFLAG(self, DB_THREAD)) {
                if (key.data != NULL) free(key.data);
                if (data.data != NULL) free(data.data);
            }
            if (err < 0 && err != DB_NOTFOUND) {
                PyErr_SetObject(dbError, makeDbError(err));
                cursor->c_close(cursor);
                RETURN_PASS();
            }
            self->size = size;
        }
        if (cursor)
        cursor->c_close(cursor);
        return PyInt_FromLong(self->size);
    }
}


static PyObject *_wrap_Db___len__(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Db___len__",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB___len__\n");
        result = (PyObject *)MyDB___len__(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB___len__\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB___getitem__(struct MyDB *self,PyObject *pyKey) {
    {
        int err;
        DBT key;
        DBT data;
        PyObject *retval;
        
        memset(&key, 0, sizeof(key));
        if (!PyArg_Parse(pyKey, "s#", &key.data, &key.size)) {
            PyErr_SetString(PyExc_TypeError, "Key must be a string.");
            RETURN_PASS();
        }
        
        memset(&data, 0, sizeof(DBT));
        if (CHECK_DBFLAG(self, DB_THREAD)) {
            // Tell BerkeleyDB to malloc the return value (thread safe)
            data.flags = DB_DBT_MALLOC;
        }
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->get(self->db, self->myenv->autoTrans, &key, &data, 0);
        MYDB_END_ALLOW_THREADS;
        if (err) {
            if (err == DB_NOTFOUND)
            PyErr_SetObject(PyExc_KeyError, pyKey);
            else
            PyErr_SetObject(dbError, makeDbError(err));
            RETURN_PASS();
        }
        
        retval = PyString_FromStringAndSize((char*)data.data, data.size);
        if (CHECK_DBFLAG(self, DB_THREAD) && (data.data != NULL)) {
free(data.data);  // free any malloc'd return value
            }

            return retval;
        }
}


static PyObject *_wrap_Db___getitem__(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    PyObject *arg1 ;
    PyObject * argo0 =0 ;
    PyObject * obj1  = 0 ;
    char *kwnames[] = {
        "self","pyKey", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OO:Db___getitem__",kwnames,&argo0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        arg1 = obj1;
    }
    {
        //printf("### Entering: MyDB___getitem__\n");
        result = (PyObject *)MyDB___getitem__(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB___getitem__\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB___setitem__(struct MyDB *self,DBT *keyp,DBT *datap) {
    {
        return MyDB_put(self, keyp, datap, self->myenv->autoTrans, 0);
    }
}


static PyObject *_wrap_Db___setitem__(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    DBT *arg1 ;
    DBT *arg2 ;
    PyObject * argo0 =0 ;
    DBT dbt ;
    PyObject * obj1  = 0 ;
    DBT dbt0 ;
    PyObject * obj2  = 0 ;
    char *kwnames[] = {
        "self","keyp","datap", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OOO:Db___setitem__",kwnames,&argo0,&obj1,&obj2)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        memset(&dbt, 0, sizeof(dbt));
        if (obj1 == Py_None) {
            dbt.data = NULL;
            dbt.size = 0;
        }else if (!PyArg_Parse(obj1, "s#", &dbt.data, &dbt.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg1 = &dbt;
    }
    {
        memset(&dbt0, 0, sizeof(dbt0));
        if (obj2 == Py_None) {
            dbt0.data = NULL;
            dbt0.size = 0;
        }else if (!PyArg_Parse(obj2, "s#", &dbt0.data, &dbt0.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg2 = &dbt0;
    }
    {
        //printf("### Entering: MyDB___setitem__\n");
        result = (PyObject *)MyDB___setitem__(arg0,arg1,arg2);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB___setitem__\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB___delitem__(struct MyDB *self,DBT *keyp) {
    {
        return MyDB_delete(self, keyp, self->myenv->autoTrans);
    }
}


static PyObject *_wrap_Db___delitem__(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    DBT *arg1 ;
    PyObject * argo0 =0 ;
    DBT dbt ;
    PyObject * obj1  = 0 ;
    char *kwnames[] = {
        "self","keyp", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OO:Db___delitem__",kwnames,&argo0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        memset(&dbt, 0, sizeof(dbt));
        if (obj1 == Py_None) {
            dbt.data = NULL;
            dbt.size = 0;
        }else if (!PyArg_Parse(obj1, "s#", &dbt.data, &dbt.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg1 = &dbt;
    }
    {
        //printf("### Entering: MyDB___delitem__\n");
        result = (PyObject *)MyDB___delitem__(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB___delitem__\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_keys(struct MyDB *self) {
    {
        int err;
        DBT key;
        DBT data;
        DBC *cursor;
        PyObject* list;
        PyObject* item;
        
        list = PyList_New(0);
        if (list == NULL) {
            PyErr_SetString(PyExc_MemoryError, "PyList_New failed");
            RETURN_PASS();
        }
        memset(&key, 0, sizeof(DBT));
        memset(&data, 0, sizeof(DBT));
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->cursor(self->db, self->myenv->autoTrans, &cursor, 0);
        MYDB_END_ALLOW_THREADS;
        RETURN_IF_ERR();
        
        while (1) {
            if (CHECK_DBFLAG(self, DB_THREAD)) {
                // XXX tons of mallocs are highly inefficient
                key.flags = DB_DBT_REALLOC;
                data.flags = DB_DBT_REALLOC;
            }
            MYDB_BEGIN_ALLOW_THREADS;
            err = cursor->c_get(cursor, &key, &data, DB_NEXT);
            MYDB_END_ALLOW_THREADS;
            if ((err != ENOMEM) && (err != 0)) {
                break;
            }
            
            item = PyString_FromStringAndSize((char*)key.data, key.size);
            if (item == NULL) {
                Py_DECREF(list);
                PyErr_SetString(PyExc_MemoryError,
                "PyString creation failed");
                list = NULL;
                goto done;
            }
            PyList_Append(list, item);
            Py_DECREF(item);
        }
        if (err < 0 && err != DB_NOTFOUND) {
            PyErr_SetObject(dbError, makeDbError(err));
            Py_DECREF(list);
            list = NULL;
            goto done;
        }
        done:
        if (CHECK_DBFLAG(self, DB_THREAD)) {
            if (key.data != NULL) free(key.data);
            if (data.data != NULL) free(data.data);
        }
        cursor->c_close(cursor);
        if (list == NULL) {
            RETURN_PASS();
        }
        return list;
    }
}


static PyObject *_wrap_Db_keys(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    PyObject * argo0 =0 ;
    char *kwnames[] = {
        "self", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"O:Db_keys",kwnames,&argo0)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        //printf("### Entering: MyDB_keys\n");
        result = (PyObject *)MyDB_keys(arg0);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_keys\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


PyObject * MyDB_has_key(struct MyDB *self,DBT *keyp) {
    {
        int err;
        DBT data;
        memset(&data, 0, sizeof(DBT));
        
        // this causes ENOMEM to be returned when the db has the key
        data.ulen = 0;
        data.data = NULL;
        data.flags = DB_DBT_USERMEM;
        
        MYDB_BEGIN_ALLOW_THREADS;
        err = self->db->get(self->db, self->myenv->autoTrans, keyp, &data, 0);
        MYDB_END_ALLOW_THREADS;
        return PyInt_FromLong((err == ENOMEM) || (err == 0));
    }
}


static PyObject *_wrap_Db_has_key(PyObject *self, PyObject *args, PyObject *kwargs) {
    PyObject *resultobj;
    struct MyDB *arg0 ;
    DBT *arg1 ;
    PyObject * argo0 =0 ;
    DBT dbt ;
    PyObject * obj1  = 0 ;
    char *kwnames[] = {
        "self","keyp", NULL 
    };
    PyObject *result ;
    
    if(!PyArg_ParseTupleAndKeywords(args,kwargs,"OO:Db_has_key",kwnames,&argo0,&obj1)) return NULL;
    if ((SWIG_ConvertPtr(argo0,(void **) &arg0,SWIGTYPE_p_MyDB,1)) == -1) return NULL;
    {
        memset(&dbt, 0, sizeof(dbt));
        if (obj1 == Py_None) {
            dbt.data = NULL;
            dbt.size = 0;
        }else if (!PyArg_Parse(obj1, "s#", &dbt.data, &dbt.size)) {
            PyErr_SetString(PyExc_TypeError,
            "Key and Data values must be of type string or None.");
            return NULL;
        }
        arg1 = &dbt;
    }
    {
        //printf("### Entering: MyDB_has_key\n");
        result = (PyObject *)MyDB_has_key(arg0,arg1);
        
        // MyDb_ErrorValue is a global; the global python thread lock must
        // be held from the time it is set through the time it gets tested
        // here.  This means all functions must call MYDB_END_ALLOW_THREADS
        // before calling RETURN_*() to test & set the global error value
        // if they ever called MYDB_BEGIN_ALLOW_THREADS.
        if (MyDb_ErrorValue == passthruError) {
            // Someone called PyErr_SetString and RETURN_PASS()
            MyDb_ErrorValue = 0;
            return NULL;
        }else if (MyDb_ErrorValue != 0) {
            // MyDb_ErrorValue contains an error set by RETURN_IF_ERR()
            PyErr_SetObject(dbError, makeDbError(MyDb_ErrorValue));
            MyDb_ErrorValue = 0;
            return NULL;
        }
        //printf("### Leaving: MyDB_has_key\n");
    }{
        resultobj = result;
    }
    return resultobj;
}


static PyMethodDef dbcMethods[] = {
	 { "version", (PyCFunction) _wrap_version, METH_VARARGS | METH_KEYWORDS },
	 { "new_Txn", (PyCFunction) _wrap_new_Txn, METH_VARARGS | METH_KEYWORDS },
	 { "Txn_abort", (PyCFunction) _wrap_Txn_abort, METH_VARARGS | METH_KEYWORDS },
	 { "Txn_prepare", (PyCFunction) _wrap_Txn_prepare, METH_VARARGS | METH_KEYWORDS },
	 { "Txn_commit", (PyCFunction) _wrap_Txn_commit, METH_VARARGS | METH_KEYWORDS },
	 { "new_DbEnv", (PyCFunction) _wrap_new_DbEnv, METH_VARARGS | METH_KEYWORDS },
	 { "delete_DbEnv", (PyCFunction) _wrap_delete_DbEnv, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_open", (PyCFunction) _wrap_DbEnv_open, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_close", (PyCFunction) _wrap_DbEnv_close, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_set_data_dir", (PyCFunction) _wrap_DbEnv_set_data_dir, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_set_lg_dir", (PyCFunction) _wrap_DbEnv_set_lg_dir, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_set_tmp_dir", (PyCFunction) _wrap_DbEnv_set_tmp_dir, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_set_cachesize", (PyCFunction) _wrap_DbEnv_set_cachesize, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_set_lg_bsize", (PyCFunction) _wrap_DbEnv_set_lg_bsize, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_set_lg_max", (PyCFunction) _wrap_DbEnv_set_lg_max, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_set_lk_detect", (PyCFunction) _wrap_DbEnv_set_lk_detect, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_set_mp_mmapsize", (PyCFunction) _wrap_DbEnv_set_mp_mmapsize, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_beginAutoTrans", (PyCFunction) _wrap_DbEnv_beginAutoTrans, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_abortAutoTrans", (PyCFunction) _wrap_DbEnv_abortAutoTrans, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_prepareAutoTrans", (PyCFunction) _wrap_DbEnv_prepareAutoTrans, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_commitAutoTrans", (PyCFunction) _wrap_DbEnv_commitAutoTrans, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_txn_begin", (PyCFunction) _wrap_DbEnv_txn_begin, METH_VARARGS | METH_KEYWORDS },
	 { "DbEnv_txn_checkpoint", (PyCFunction) _wrap_DbEnv_txn_checkpoint, METH_VARARGS | METH_KEYWORDS },
	 { "delete_Dbc", (PyCFunction) _wrap_delete_Dbc, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_close", (PyCFunction) _wrap_Dbc_close, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_delete", (PyCFunction) _wrap_Dbc_delete, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_get", (PyCFunction) _wrap_Dbc_get, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_first", (PyCFunction) _wrap_Dbc_first, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_last", (PyCFunction) _wrap_Dbc_last, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_next", (PyCFunction) _wrap_Dbc_next, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_prev", (PyCFunction) _wrap_Dbc_prev, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_current", (PyCFunction) _wrap_Dbc_current, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_set", (PyCFunction) _wrap_Dbc_set, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_setRange", (PyCFunction) _wrap_Dbc_setRange, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_setRecno", (PyCFunction) _wrap_Dbc_setRecno, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_getRecno", (PyCFunction) _wrap_Dbc_getRecno, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_put", (PyCFunction) _wrap_Dbc_put, METH_VARARGS | METH_KEYWORDS },
	 { "Dbc_count", (PyCFunction) _wrap_Dbc_count, METH_VARARGS | METH_KEYWORDS },
	 { "new_Db", (PyCFunction) _wrap_new_Db, METH_VARARGS | METH_KEYWORDS },
	 { "delete_Db", (PyCFunction) _wrap_delete_Db, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_cachesize", (PyCFunction) _wrap_Db_set_cachesize, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_lorder", (PyCFunction) _wrap_Db_set_lorder, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_pagesize", (PyCFunction) _wrap_Db_set_pagesize, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_bt_minkey", (PyCFunction) _wrap_Db_set_bt_minkey, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_h_ffactor", (PyCFunction) _wrap_Db_set_h_ffactor, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_h_nelem", (PyCFunction) _wrap_Db_set_h_nelem, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_re_delim", (PyCFunction) _wrap_Db_set_re_delim, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_re_len", (PyCFunction) _wrap_Db_set_re_len, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_re_pad", (PyCFunction) _wrap_Db_set_re_pad, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_re_source", (PyCFunction) _wrap_Db_set_re_source, METH_VARARGS | METH_KEYWORDS },
	 { "Db_set_flags", (PyCFunction) _wrap_Db_set_flags, METH_VARARGS | METH_KEYWORDS },
	 { "Db_open", (PyCFunction) _wrap_Db_open, METH_VARARGS | METH_KEYWORDS },
	 { "Db_upgrade", (PyCFunction) _wrap_Db_upgrade, METH_VARARGS | METH_KEYWORDS },
	 { "Db_type", (PyCFunction) _wrap_Db_type, METH_VARARGS | METH_KEYWORDS },
	 { "Db_close", (PyCFunction) _wrap_Db_close, METH_VARARGS | METH_KEYWORDS },
	 { "Db_cursor", (PyCFunction) _wrap_Db_cursor, METH_VARARGS | METH_KEYWORDS },
	 { "Db_delete", (PyCFunction) _wrap_Db_delete, METH_VARARGS | METH_KEYWORDS },
	 { "Db_get", (PyCFunction) _wrap_Db_get, METH_VARARGS | METH_KEYWORDS },
	 { "Db_getRec", (PyCFunction) _wrap_Db_getRec, METH_VARARGS | METH_KEYWORDS },
	 { "Db_fd", (PyCFunction) _wrap_Db_fd, METH_VARARGS | METH_KEYWORDS },
	 { "Db_put", (PyCFunction) _wrap_Db_put, METH_VARARGS | METH_KEYWORDS },
	 { "Db_sync", (PyCFunction) _wrap_Db_sync, METH_VARARGS | METH_KEYWORDS },
	 { "Db___len__", (PyCFunction) _wrap_Db___len__, METH_VARARGS | METH_KEYWORDS },
	 { "Db___getitem__", (PyCFunction) _wrap_Db___getitem__, METH_VARARGS | METH_KEYWORDS },
	 { "Db___setitem__", (PyCFunction) _wrap_Db___setitem__, METH_VARARGS | METH_KEYWORDS },
	 { "Db___delitem__", (PyCFunction) _wrap_Db___delitem__, METH_VARARGS | METH_KEYWORDS },
	 { "Db_keys", (PyCFunction) _wrap_Db_keys, METH_VARARGS | METH_KEYWORDS },
	 { "Db_has_key", (PyCFunction) _wrap_Db_has_key, METH_VARARGS | METH_KEYWORDS },
	 { NULL, NULL }
};

#ifdef __cplusplus
}
#endif

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_MyDB_ENV[] = {{"_p_MyDB_ENV", 0, "struct MyDB_ENV *"},{"_p_MyDB_ENV"},{0}};
static swig_type_info _swigt__p___db_txn[] = {{"_p___db_txn", 0, "struct __db_txn *"},{"_p___db_txn"},{0}};
static swig_type_info _swigt__p_MyDB[] = {{"_p_MyDB", 0, "struct MyDB *"},{"_p_MyDB"},{0}};
static swig_type_info _swigt__p_MyDBC[] = {{"_p_MyDBC", 0, "struct MyDBC *"},{"_p_MyDBC"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_MyDB_ENV, 
_swigt__p___db_txn, 
_swigt__p_MyDB, 
_swigt__p_MyDBC, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

static swig_const_info swig_const_table[] = {
    { SWIG_PY_STRING, "__version__", 0, 0, (void *) "2.2.3", 0 }, 
    { SWIG_PY_STRING, "cvsid", 0, 0, (void *) "$Id$", 0 }, 
    { SWIG_PY_INT,     "DB_VERSION_MAJOR", (long) DB_VERSION_MAJOR, 0, 0, 0},
    { SWIG_PY_INT,     "DB_VERSION_MINOR", (long) DB_VERSION_MINOR, 0, 0, 0},
    { SWIG_PY_INT,     "DB_VERSION_PATCH", (long) DB_VERSION_PATCH, 0, 0, 0},
    { SWIG_PY_INT,     "DB_VERSION_STRING", (long) DB_VERSION_STRING, 0, 0, 0},
    { SWIG_PY_INT,     "DB_MAX_PAGES", (long) DB_MAX_PAGES, 0, 0, 0},
    { SWIG_PY_INT,     "DB_MAX_RECORDS", (long) DB_MAX_RECORDS, 0, 0, 0},
    { SWIG_PY_INT,     "DB_DBT_PARTIAL", (long) DB_DBT_PARTIAL, 0, 0, 0},
    { SWIG_PY_INT,     "DB_XA_CREATE", (long) DB_XA_CREATE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_CREATE", (long) DB_CREATE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_NOMMAP", (long) DB_NOMMAP, 0, 0, 0},
    { SWIG_PY_INT,     "DB_THREAD", (long) DB_THREAD, 0, 0, 0},
    { SWIG_PY_INT,     "DB_INIT_CDB", (long) DB_INIT_CDB, 0, 0, 0},
    { SWIG_PY_INT,     "DB_INIT_LOCK", (long) DB_INIT_LOCK, 0, 0, 0},
    { SWIG_PY_INT,     "DB_INIT_LOG", (long) DB_INIT_LOG, 0, 0, 0},
    { SWIG_PY_INT,     "DB_INIT_MPOOL", (long) DB_INIT_MPOOL, 0, 0, 0},
    { SWIG_PY_INT,     "DB_INIT_TXN", (long) DB_INIT_TXN, 0, 0, 0},
    { SWIG_PY_INT,     "DB_RECOVER", (long) DB_RECOVER, 0, 0, 0},
    { SWIG_PY_INT,     "DB_RECOVER_FATAL", (long) DB_RECOVER_FATAL, 0, 0, 0},
    { SWIG_PY_INT,     "DB_TXN_NOSYNC", (long) DB_TXN_NOSYNC, 0, 0, 0},
    { SWIG_PY_INT,     "DB_USE_ENVIRON", (long) DB_USE_ENVIRON, 0, 0, 0},
    { SWIG_PY_INT,     "DB_USE_ENVIRON_ROOT", (long) DB_USE_ENVIRON_ROOT, 0, 0, 0},
    { SWIG_PY_INT,     "DB_LOCKDOWN", (long) DB_LOCKDOWN, 0, 0, 0},
    { SWIG_PY_INT,     "DB_PRIVATE", (long) DB_PRIVATE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_TXN_SYNC", (long) DB_TXN_SYNC, 0, 0, 0},
    { SWIG_PY_INT,     "DB_TXN_NOWAIT", (long) DB_TXN_NOWAIT, 0, 0, 0},
    { SWIG_PY_INT,     "DB_FORCE", (long) DB_FORCE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_EXCL", (long) DB_EXCL, 0, 0, 0},
    { SWIG_PY_INT,     "DB_RDONLY", (long) DB_RDONLY, 0, 0, 0},
    { SWIG_PY_INT,     "DB_TRUNCATE", (long) DB_TRUNCATE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_LOCK_NORUN", (long) DB_LOCK_NORUN, 0, 0, 0},
    { SWIG_PY_INT,     "DB_LOCK_DEFAULT", (long) DB_LOCK_DEFAULT, 0, 0, 0},
    { SWIG_PY_INT,     "DB_LOCK_OLDEST", (long) DB_LOCK_OLDEST, 0, 0, 0},
    { SWIG_PY_INT,     "DB_LOCK_RANDOM", (long) DB_LOCK_RANDOM, 0, 0, 0},
    { SWIG_PY_INT,     "DB_LOCK_YOUNGEST", (long) DB_LOCK_YOUNGEST, 0, 0, 0},
    { SWIG_PY_INT,     "DB_BTREE", (long) DB_BTREE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_HASH", (long) DB_HASH, 0, 0, 0},
    { SWIG_PY_INT,     "DB_RECNO", (long) DB_RECNO, 0, 0, 0},
    { SWIG_PY_INT,     "DB_UNKNOWN", (long) DB_UNKNOWN, 0, 0, 0},
    { SWIG_PY_INT,     "DB_DUP", (long) DB_DUP, 0, 0, 0},
    { SWIG_PY_INT,     "DB_DUPSORT", (long) DB_DUPSORT, 0, 0, 0},
    { SWIG_PY_INT,     "DB_RECNUM", (long) DB_RECNUM, 0, 0, 0},
    { SWIG_PY_INT,     "DB_RENUMBER", (long) DB_RENUMBER, 0, 0, 0},
    { SWIG_PY_INT,     "DB_REVSPLITOFF", (long) DB_REVSPLITOFF, 0, 0, 0},
    { SWIG_PY_INT,     "DB_SNAPSHOT", (long) DB_SNAPSHOT, 0, 0, 0},
    { SWIG_PY_INT,     "DB_AFTER", (long) DB_AFTER, 0, 0, 0},
    { SWIG_PY_INT,     "DB_APPEND", (long) DB_APPEND, 0, 0, 0},
    { SWIG_PY_INT,     "DB_BEFORE", (long) DB_BEFORE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_CHECKPOINT", (long) DB_CHECKPOINT, 0, 0, 0},
    { SWIG_PY_INT,     "DB_CONSUME", (long) DB_CONSUME, 0, 0, 0},
    { SWIG_PY_INT,     "DB_CURLSN", (long) DB_CURLSN, 0, 0, 0},
    { SWIG_PY_INT,     "DB_CURRENT", (long) DB_CURRENT, 0, 0, 0},
    { SWIG_PY_INT,     "DB_FIRST", (long) DB_FIRST, 0, 0, 0},
    { SWIG_PY_INT,     "DB_FLUSH", (long) DB_FLUSH, 0, 0, 0},
    { SWIG_PY_INT,     "DB_GET_BOTH", (long) DB_GET_BOTH, 0, 0, 0},
    { SWIG_PY_INT,     "DB_GET_RECNO", (long) DB_GET_RECNO, 0, 0, 0},
    { SWIG_PY_INT,     "DB_JOIN_ITEM", (long) DB_JOIN_ITEM, 0, 0, 0},
    { SWIG_PY_INT,     "DB_KEYFIRST", (long) DB_KEYFIRST, 0, 0, 0},
    { SWIG_PY_INT,     "DB_KEYLAST", (long) DB_KEYLAST, 0, 0, 0},
    { SWIG_PY_INT,     "DB_LAST", (long) DB_LAST, 0, 0, 0},
    { SWIG_PY_INT,     "DB_NEXT", (long) DB_NEXT, 0, 0, 0},
    { SWIG_PY_INT,     "DB_NEXT_DUP", (long) DB_NEXT_DUP, 0, 0, 0},
    { SWIG_PY_INT,     "DB_NEXT_NODUP", (long) DB_NEXT_NODUP, 0, 0, 0},
    { SWIG_PY_INT,     "DB_NOOVERWRITE", (long) DB_NOOVERWRITE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_NOSYNC", (long) DB_NOSYNC, 0, 0, 0},
    { SWIG_PY_INT,     "DB_POSITION", (long) DB_POSITION, 0, 0, 0},
    { SWIG_PY_INT,     "DB_PREV", (long) DB_PREV, 0, 0, 0},
    { SWIG_PY_INT,     "DB_RECORDCOUNT", (long) DB_RECORDCOUNT, 0, 0, 0},
    { SWIG_PY_INT,     "DB_SET", (long) DB_SET, 0, 0, 0},
    { SWIG_PY_INT,     "DB_SET_RANGE", (long) DB_SET_RANGE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_SET_RECNO", (long) DB_SET_RECNO, 0, 0, 0},
    { SWIG_PY_INT,     "DB_WRITECURSOR", (long) DB_WRITECURSOR, 0, 0, 0},
    { SWIG_PY_INT,     "DB_OPFLAGS_MASK", (long) DB_OPFLAGS_MASK, 0, 0, 0},
    { SWIG_PY_INT,     "DB_RMW", (long) DB_RMW, 0, 0, 0},
    { SWIG_PY_INT,     "DB_INCOMPLETE", (long) DB_INCOMPLETE, 0, 0, 0},
    { SWIG_PY_INT,     "DB_KEYEMPTY", (long) DB_KEYEMPTY, 0, 0, 0},
    { SWIG_PY_INT,     "DB_KEYEXIST", (long) DB_KEYEXIST, 0, 0, 0},
    { SWIG_PY_INT,     "DB_LOCK_DEADLOCK", (long) DB_LOCK_DEADLOCK, 0, 0, 0},
    { SWIG_PY_INT,     "DB_LOCK_NOTGRANTED", (long) DB_LOCK_NOTGRANTED, 0, 0, 0},
    { SWIG_PY_INT,     "DB_NOTFOUND", (long) DB_NOTFOUND, 0, 0, 0},
    { SWIG_PY_INT,     "DB_OLD_VERSION", (long) DB_OLD_VERSION, 0, 0, 0},
    { SWIG_PY_INT,     "DB_RUNRECOVERY", (long) DB_RUNRECOVERY, 0, 0, 0},
{0}};

static PyObject *SWIG_globals;
#ifdef __cplusplus
extern "C" 
#endif
SWIGEXPORT(void) initdbc(void) {
    PyObject *m, *d;
    int i;
    SWIG_globals = SWIG_newvarlink();
    m = Py_InitModule("dbc", dbcMethods);
    d = PyModule_GetDict(m);
    for (i = 0; swig_types_initial[i]; i++) {
        swig_types[i] = SWIG_TypeRegister(swig_types_initial[i]);
    }
    
    dbError = PyString_FromString("db.error");
    PyDict_SetItemString(d,"error", dbError);
    SWIG_InstallConstants(d,swig_const_table);
}

